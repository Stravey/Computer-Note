# 5.2 指令执行过程

## 5.2.1 指令周期

指令周期：CPU从主存中每取出并执行一条指令所需的全部时间。

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E6%9C%BA%E5%99%A8%E5%91%A8%E6%9C%9F.png)

一个**指令周期**由若干**机器周期**表示，机器周期也叫**CUP周期**。

一个**机器周期**包含若干**时钟周期（节拍）**，时钟周期是CPU操作的最基本单位。

- 每个指令周期内机器周期可以不相等
- 每个机器周期内节拍数也可以不相等

完整的指令周期如图所示：

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E6%8C%87%E4%BB%A4%E5%91%A8%E6%9C%9F%E6%B5%81%E7%A8%8B.png)

运行时，通过**触发器**来判断当前处于指令周期内的哪一个阶段。

> 中断周期的进栈操作是将 SP 减 1 ，原因是计算机中的堆栈都是向低地址方向增长的。

## 5.2.2 指令周期的数据流

### 1 寻址周期

**寻址周期：**根据PC中的内容从主存储器中取出指令代码并存放在IR中。

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E5%8F%96%E5%9D%80%E5%91%A8%E6%9C%9F.png)

1. 将当前指令地址送到**存储地址寄存器**
   1. (PC)→MAR
2. CU发出控制信号，由控制总线传到主存，标明是**读信号**
   1. 1→R
3. 将MAR指向的主存中的内容经**数据总线**传至MDR
   1. M(MAR)→MDR
4. 将MDR中的数据送入**指令寄存器IR**
   1. (MDR)→IR
5. CU发出控制信号，形成下一条指令的地址
   1. (PC)+1→PC

### 2 寻址周期

寻址周期：取操作数有效地址。

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E9%97%B4%E5%9D%80%E5%91%A8%E6%9C%9F.png)

1. 将指令的地址码送入MAR
   1. Ad(IR)→MAR
2. CU发出控制信号，表示读操作
   1. 1→R
3. 将MAR所指主存中的内容传入MDR
   1. M(MAR)→MDR
4. 将得到的有效地址送入IR
   1. (MDR)→Ad(IR)

### 3 执行周期

**执行周期：**取操作数，根据IR中的指令字的操作码通过ALU操作产生执行结果。

执行周期的数据流向视不同指令而定，没有统一的数据流向。

### 4 中断周期

![img](https://github.com/Aye10032/ComputerOrganizationNote/raw/main/.gitbook/assets/%E4%B8%AD%E6%96%AD%E5%91%A8%E6%9C%9F.png)

中断执行前需要保存当前程序的**断点**。断点一般采用堆栈保存，SP为栈顶指针，进栈的操作顺序为先修改指针，再存入数据。

1. CU控制SP减一，并将修改后的栈顶地址存入MAR
   1. (SP)-1→SP
   2. (SP)→MAR
2. CU发出控制信号，表明当前为写操作
   1. 1→W
3. 将断点内容（PC内容）存入MDR
   1. (PC)→MDR
4. CU将中断程序的入口地址存入PC
   1. 向量地址→PC

## 5.2.3 指令执行方案

### 1 单指令处理器

对所有指令都选**用相同的执行时间来完成**。指令之间**串行执行**，指令周期取决于执行时间最长的指令的执行时间。

会降低整个系统的运行速度。

### 2 多指令处理器

对不同类型的指令**选用不同的执行步骤来完成**。 指令之间**串行执行**，可选用不同个数的时钟周期来完成不同指令的执行过程。

需要更复杂的硬件设计。

### 3 流水线处理器

在每一个时钟周期启动一条指令，尽量让多条指令**同时运行**，但各自处在**不同的执行步骤**中。 指令之间**并行执行**。